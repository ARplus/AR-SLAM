<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>
  <body>
    <a-scene mindar-image="imageTargetSrc: ./qianfo.mind" 
             color-space="sRGB" 
             renderer="colorManagement: true, physicallyCorrectLights" 
             vr-mode-ui="enabled: false" 
             device-orientation-permission-ui="enabled: false">
      
      <a-assets>
        <video id="video" autoplay loop muted playsinline src="./video.mp4" crossorigin="anonymous"></video>
        <canvas id="chromaCanvas" width="512" height="512"></canvas>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      
      <a-entity mindar-image-target="targetIndex: 0">
        <!-- 1:1比例的正方形视频，使用处理后的canvas作为纹理 -->
        <a-plane src="#chromaCanvas" width="1" height="1" position="0 0 0.01"
                 material="transparent: true; alphaTest: 0.1"></a-plane>
      </a-entity>
      
    </a-scene>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const video = document.querySelector('#video');
        const canvas = document.querySelector('#chromaCanvas');
        const ctx = canvas.getContext('2d');
        let plane;
        let canvasTexture;
        
        // 优化的绿幕抠图参数
        const chromaKey = {
          hueThreshold: 15,      // HSV色相阈值
          satThreshold: 0.3,     // 饱和度阈值
          valThreshold: 0.4,     // 明度阈值
          smoothing: 0.1         // 边缘平滑
        };
        
        // RGB转HSV函数
        function rgbToHsv(r, g, b) {
          r /= 255; g /= 255; b /= 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const diff = max - min;
          
          let h = 0;
          if (diff !== 0) {
            if (max === r) h = ((g - b) / diff) % 6;
            else if (max === g) h = (b - r) / diff + 2;
            else h = (r - g) / diff + 4;
          }
          h = Math.round(h * 60);
          if (h < 0) h += 360;
          
          const s = max === 0 ? 0 : diff / max;
          const v = max;
          
          return [h, s, v];
        }
        
        function setupTexture() {
          // 获取A-Frame平面元素
          plane = document.querySelector('a-plane');
          
          // 创建Three.js纹理并应用到材质
          if (plane && plane.getObject3D('mesh')) {
            canvasTexture = new THREE.CanvasTexture(canvas);
            canvasTexture.flipY = true; // 修复上下反转问题
            
            const material = new THREE.MeshBasicMaterial({
              map: canvasTexture,
              transparent: true,
              alphaTest: 0.1
            });
            
            plane.getObject3D('mesh').material = material;
            console.log('纹理设置完成');
          }
        }
        
        function processChromaKey() {
          if (video.readyState >= video.HAVE_CURRENT_DATA) {
            // 绘制视频到canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // 获取图像数据
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 使用HSV颜色空间进行更精确的绿幕抠图
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const originalAlpha = data[i + 3];
              
              // 转换到HSV颜色空间
              const [h, s, v] = rgbToHsv(r, g, b);
              
              // 绿色在HSV中的色相范围大约是60-180度
              // 我们重点检测120度附近的绿色（纯绿色）
              const isGreenHue = (h >= 60 && h <= 180);
              const isGreenishHue = Math.abs(h - 120) <= chromaKey.hueThreshold || 
                                   Math.abs(h - 120 + 360) <= chromaKey.hueThreshold;
              
              // 检查饱和度和明度
              const hasSufficientSaturation = s >= chromaKey.satThreshold;
              const hasSufficientValue = v >= chromaKey.valThreshold;
              
              // 只有同时满足色相、饱和度、明度条件的像素才被认为是绿幕
              if (isGreenHue && isGreenishHue && hasSufficientSaturation && hasSufficientValue) {
                // 计算透明度：基于与标准绿色的距离
                const greenDistance = Math.abs(h - 120) / chromaKey.hueThreshold;
                const satDistance = Math.abs(s - 1.0);
                const valDistance = Math.abs(v - 1.0);
                
                // 综合距离计算
                const totalDistance = (greenDistance + satDistance + valDistance) / 3;
                
                // 平滑的透明度过渡
                let alpha = Math.min(1, totalDistance + chromaKey.smoothing);
                alpha = Math.max(0, alpha);
                
                data[i + 3] = originalAlpha * alpha;
              }
              // 对于非绿色像素，保持原始颜色和透明度不变
            }
            
            // 将处理后的数据写回canvas
            ctx.putImageData(imageData, 0, 0);
            
            // 通知Three.js纹理已更新
            if (canvasTexture) {
              canvasTexture.needsUpdate = true;
            }
          }
          
          // 继续下一帧
          requestAnimationFrame(processChromaKey);
        }
        
        // 当A-Frame场景加载完成时设置纹理
        document.querySelector('a-scene').addEventListener('loaded', function() {
          setTimeout(setupTexture, 100); // 稍微延迟确保元素完全加载
        });
        
        // 当视频准备好时开始处理
        video.addEventListener('loadeddata', function() {
          console.log('视频加载完成，开始绿幕抠图处理');
          processChromaKey();
        });
        
        video.addEventListener('error', function(e) {
          console.error('视频加载错误:', e);
        });
      });
    </script>
  </body>
</html>
