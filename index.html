<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>
  <body>
    <a-scene mindar-image="imageTargetSrc: ./qianfo.mind" 
             color-space="sRGB" 
             renderer="colorManagement: true, physicallyCorrectLights" 
             vr-mode-ui="enabled: false" 
             device-orientation-permission-ui="enabled: false">
      
      <a-assets>
        <video id="video" autoplay loop muted playsinline src="./video.mp4" crossorigin="anonymous"></video>
        <canvas id="chromaCanvas" width="512" height="512"></canvas>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      
      <a-entity mindar-image-target="targetIndex: 0">
        <!-- 1:1比例的正方形视频，使用处理后的canvas作为纹理 -->
        <a-plane src="#chromaCanvas" width="1" height="1" position="0 0 0.01"
                 material="transparent: true; alphaTest: 0.1"></a-plane>
      </a-entity>
      
    </a-scene>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const video = document.querySelector('#video');
        const canvas = document.querySelector('#chromaCanvas');
        const ctx = canvas.getContext('2d');
        let plane;
        let canvasTexture;
        
        // 绿幕抠图参数 - 优化后的设置
        const chromaKey = {
          threshold: 60,  // 降低阈值，更精确
          smoothing: 20   // 减少平滑度，保持颜色准确
        };
        
        // 图像增强参数
        const imageEnhancement = {
          contrast: 1.3,      // 对比度增强
          brightness: 1.1,    // 轻微增加亮度
          saturation: 1.2     // 增加饱和度
        };
        
        function setupTexture() {
          // 获取A-Frame平面元素
          plane = document.querySelector('a-plane');
          
          // 创建Three.js纹理并应用到材质
          if (plane && plane.getObject3D('mesh')) {
            canvasTexture = new THREE.CanvasTexture(canvas);
            canvasTexture.flipY = true; // 修复上下反转问题
            
            const material = new THREE.MeshBasicMaterial({
              map: canvasTexture,
              transparent: true,
              alphaTest: 0.1
            });
            
            plane.getObject3D('mesh').material = material;
            console.log('纹理设置完成');
          }
        }
        
        // 增强图像对比度和饱和度
        function enhanceImage(imageData) {
          const data = imageData.data;
          const contrast = imageEnhancement.contrast;
          const brightness = imageEnhancement.brightness;
          const saturation = imageEnhancement.saturation;
          
          for (let i = 0; i < data.length; i += 4) {
            let r = data[i];
            let g = data[i + 1];
            let b = data[i + 2];
            
            // 对比度调整
            r = ((r / 255 - 0.5) * contrast + 0.5) * 255;
            g = ((g / 255 - 0.5) * contrast + 0.5) * 255;
            b = ((b / 255 - 0.5) * contrast + 0.5) * 255;
            
            // 亮度调整
            r *= brightness;
            g *= brightness;
            b *= brightness;
            
            // 饱和度调整
            const gray = 0.299 * r + 0.587 * g + 0.114 * b;
            r = gray + (r - gray) * saturation;
            g = gray + (g - gray) * saturation;
            b = gray + (b - gray) * saturation;
            
            // 限制在0-255范围内
            data[i] = Math.max(0, Math.min(255, r));
            data[i + 1] = Math.max(0, Math.min(255, g));
            data[i + 2] = Math.max(0, Math.min(255, b));
          }
          
          return imageData;
        }
        
        function processChromaKey() {
          if (video.readyState >= video.HAVE_CURRENT_DATA) {
            // 绘制视频到canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // 获取图像数据
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // 增强图像对比度和饱和度
            imageData = enhanceImage(imageData);
            
            const data = imageData.data;
            
            // 更精确的绿幕抠图算法
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              
              // 改进的绿色检测算法
              // 1. 绿色必须是主导色
              // 2. 绿色必须明显高于红色和蓝色
              // 3. 避免处理暗绿色（可能是阴影）
              const isGreenDominant = g > r && g > b;
              const greenStrength = g - Math.max(r, b);
              const isBrightEnough = g > 120; // 避免处理暗色
              const colorDistance = Math.sqrt((r-0)*(r-0) + (g-255)*(g-255) + (b-0)*(b-0));
              
              // 只有满足所有条件才进行抠图
              if (isGreenDominant && greenStrength > chromaKey.threshold && isBrightEnough && colorDistance < 150) {
                // 根据绿色强度计算透明度
                const intensity = greenStrength / 100;
                const alpha = Math.max(0, 1 - intensity);
                data[i + 3] = data[i + 3] * alpha;
              }
            }
            
            // 将处理后的数据写回canvas
            ctx.putImageData(imageData, 0, 0);
            
            // 通知Three.js纹理已更新
            if (canvasTexture) {
              canvasTexture.needsUpdate = true;
            }
          }
          
          // 继续下一帧
          requestAnimationFrame(processChromaKey);
        }
        
        // 当A-Frame场景加载完成时设置纹理
        document.querySelector('a-scene').addEventListener('loaded', function() {
          setTimeout(setupTexture, 100); // 稍微延迟确保元素完全加载
        });
        
        // 当视频准备好时开始处理
        video.addEventListener('loadeddata', function() {
          console.log('视频加载完成，开始绿幕抠图处理');
          processChromaKey();
        });
        
        video.addEventListener('error', function(e) {
          console.error('视频加载错误:', e);
        });
      });
    </script>
  </body>
</html>
