<html>
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <script src="https://aframe.io/releases/1.6.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.5/dist/mindar-image-aframe.prod.js"></script>
  </head>
  <body>
    <a-scene mindar-image="imageTargetSrc: ./qianfo.mind" 
             color-space="sRGB" 
             renderer="colorManagement: true, physicallyCorrectLights" 
             vr-mode-ui="enabled: false" 
             device-orientation-permission-ui="enabled: false">
      
      <a-assets>
        <video id="video" autoplay loop muted playsinline src="./video.mp4" crossorigin="anonymous"></video>
        <canvas id="chromaCanvas" width="512" height="512"></canvas>
      </a-assets>

      <a-camera position="0 0 0" look-controls="enabled: false"></a-camera>
      
      <a-entity mindar-image-target="targetIndex: 0">
        <!-- 1:1比例的正方形视频，使用处理后的canvas作为纹理 -->
        <a-plane src="#chromaCanvas" width="1" height="1" position="0 0 0.01"
                 material="transparent: true; alphaTest: 0.1"></a-plane>
      </a-entity>
      
    </a-scene>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
        const video = document.querySelector('#video');
        const canvas = document.querySelector('#chromaCanvas');
        const ctx = canvas.getContext('2d');
        let plane;
        let canvasTexture;
        
        // 简化但更有效的绿幕抠图参数
        const chromaKey = {
          threshold: 50,     // 绿色强度阈值
          tolerance: 80,     // 绿色容忍度
          smoothing: 15      // 边缘平滑
        };
        
        function setupTexture() {
          // 获取A-Frame平面元素
          plane = document.querySelector('a-plane');
          
          // 创建Three.js纹理并应用到材质
          if (plane && plane.getObject3D('mesh')) {
            canvasTexture = new THREE.CanvasTexture(canvas);
            canvasTexture.flipY = true; // 修复上下反转问题
            
            const material = new THREE.MeshBasicMaterial({
              map: canvasTexture,
              transparent: true,
              alphaTest: 0.1
            });
            
            plane.getObject3D('mesh').material = material;
            console.log('纹理设置完成');
          }
        }
        
        function processChromaKey() {
          if (video.readyState >= video.HAVE_CURRENT_DATA) {
            // 绘制视频到canvas
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            
            // 获取图像数据
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            // 简单有效的绿幕抠图算法
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              
              // 绿幕检测：绿色明显高于红色和蓝色
              const greenStrength = g - Math.max(r, b);
              const greenDominance = g / (r + b + 1); // 避免除零
              
              // 检测是否为绿幕像素
              const isGreenScreen = (
                greenStrength > chromaKey.threshold &&    // 绿色强度足够
                g > 100 &&                                // 足够亮
                greenDominance > 1.2 &&                  // 绿色占主导
                Math.abs(r - b) < 50                     // 红蓝相近（避免误判）
              );
              
              if (isGreenScreen) {
                // 计算到纯绿色的距离
                const greenDistance = Math.sqrt(
                  (r - 0) * (r - 0) + 
                  (g - 255) * (g - 255) + 
                  (b - 0) * (b - 0)
                );
                
                // 基于距离计算透明度
                if (greenDistance < chromaKey.tolerance) {
                  data[i + 3] = 0; // 完全透明
                } else if (greenDistance < chromaKey.tolerance + chromaKey.smoothing) {
                  // 边缘平滑
                  const alpha = (greenDistance - chromaKey.tolerance) / chromaKey.smoothing;
                  data[i + 3] = Math.min(255, data[i + 3] * alpha);
                }
              }
            }
            
            // 将处理后的数据写回canvas
            ctx.putImageData(imageData, 0, 0);
            
            // 通知Three.js纹理已更新
            if (canvasTexture) {
              canvasTexture.needsUpdate = true;
            }
          }
          
          // 继续下一帧
          requestAnimationFrame(processChromaKey);
        }
        
        // 当A-Frame场景加载完成时设置纹理
        document.querySelector('a-scene').addEventListener('loaded', function() {
          setTimeout(setupTexture, 100); // 稍微延迟确保元素完全加载
        });
        
        // 当视频准备好时开始处理
        video.addEventListener('loadeddata', function() {
          console.log('视频加载完成，开始绿幕抠图处理');
          processChromaKey();
        });
        
        video.addEventListener('error', function(e) {
          console.error('视频加载错误:', e);
        });
      });
    </script>
  </body>
</html>
